(clojure.core/let [prefix__641__auto__ (clojure.core/name (clojure.core/gensym)) code__642__auto__ (.replaceAll "(ns unrepl.print\n  (:require [clojure.string :as str]\n    [clojure.edn :as edn]))\n\n(def ^:dynamic *elide* (constantly nil))\n\n(deftype ElidedKVs [s]\n  clojure.lang.Seqable\n  (seq [_] (seq s)))\n\n(def atomic? (some-fn nil? true? false? char? string? symbol? keyword? #(and (number? %) (not (ratio? %)))))\n\n(defn- as-str\n  \"Like pr-str but escapes all ASCII conytrol chars.\"\n  [x]\n  ;hacky\n  (cond\n    (string? x) (str/replace (pr-str x) #\"\\p{Cntrl}\"\n                  #(format \"\\\\u%04x\" (int (.charAt ^String % 0))))\n    (char? x) (str/replace (pr-str x) #\"\\p{Cntrl}\"\n                #(format \"u%04x\" (int (.charAt ^String % 0))))\n    :else (pr-str x)))\n\n(defn- insert-class [classes ^Class class]\n  (let [ancestor-or-self? #(.isAssignableFrom ^Class % class)]\n    (-> []\n     (into (remove ancestor-or-self?) classes)\n     (conj class)\n     (into (filter ancestor-or-self?) classes))))\n\n(def ^:dynamic *attach* nil)\n\n(defmacro ^:private latent-fn [& fn-body]\n  `(let [d# (delay (binding [*ns* (find-ns '~(ns-name *ns*))] (eval '(fn ~@fn-body))))]\n     (fn\n       ([] (@d#))\n       ([x#] (@d# x#))\n       ([x# & xs#] (apply @d# x# xs#)))))\n\n(defn- as-inst [x]\n  (edn/read-string {:readers {'inst #(tagged-literal 'inst %)}} (pr-str x)))\n\n(def ^:dynamic *object-representations*\n  \"map of classes to functions returning their representation component (3rd item in #unrepl/object [class id rep])\"\n  {clojure.lang.IDeref\n   (fn [x]\n     (let [pending? (and (instance? clojure.lang.IPending x) ; borrowed from https://github.com/brandonbloom/fipp/blob/8df75707e355c1a8eae5511b7d73c1b782f57293/src/fipp/ednize.clj#L37-L51\n                      (not (.isRealized ^clojure.lang.IPending x)))\n           [ex val] (when-not pending?\n                      (try [false @x]\n                        (catch Throwable e\n                          [true e])))\n           failed? (or ex (and (instance? clojure.lang.Agent x)\n                            (agent-error x)))\n           status (cond\n                    failed? :failed\n                    pending? :pending\n                    :else :ready)]\n       {:unrepl.ref/status status :unrepl.ref/val val}))\n   \n   java.io.File (fn [^java.io.File f]\n                  (into {:path (.getPath f)}\n                    (when (and *attach* (.isFile f))\n                      {:attachment (tagged-literal 'unrepl/mime\n                                     (into {:content-type \"application/octet-stream\"\n                                           :content-length (.length f)}\n                                       (*attach* #(java.io.FileInputStream. f))))})))\n   \n   java.awt.Image (latent-fn [^java.awt.Image img]\n                    (let [w (.getWidth img nil)\n                          h (.getHeight img nil)]\n                      (into {:width w, :height h}\n                       (when *attach*\n                         {:attachment\n                          (tagged-literal 'unrepl/mime\n                            (into {:content-type \"image/png\"}\n                              (*attach* #(let [bos (java.io.ByteArrayOutputStream.)]\n                                               (when (javax.imageio.ImageIO/write\n                                                       (doto (java.awt.image.BufferedImage. w h java.awt.image.BufferedImage/TYPE_INT_ARGB)\n                                                         (-> .getGraphics (.drawImage img 0 0 nil)))\n                                                       \"png\" bos)\n                                                 (java.io.ByteArrayInputStream. (.toByteArray bos)))))))}))))\n   \n   Object (fn [x]\n            (if (-> x class .isArray)\n              (seq x)\n              (str x)))})\n\n(defn- object-representation [x]  \n  (reduce-kv (fn [_ class f]\n               (when (instance? class x) (reduced (f x)))) nil *object-representations*)) ; todo : cache\n\n(defprotocol DefaultEdnize\n  (default-ednize [x]))\n\n(defn- class-form [^Class x]\n  (if (.isArray x) [(-> x .getComponentType class-form)] (symbol (.getName x))))\n\n(extend-protocol DefaultEdnize\n  clojure.lang.TaggedLiteral (default-ednize [x] x)\n  clojure.lang.Ratio (default-ednize [^clojure.lang.Ratio x] (tagged-literal 'unrepl/ratio [(.numerator x) (.denominator x)]))\n  Throwable (default-ednize [t] (tagged-literal 'error (Throwable->map t)))\n  Class (default-ednize [x] (tagged-literal 'unrepl.java/class (class-form x)))\n  java.util.Date (default-ednize [x] (as-inst x))\n  java.util.Calendar (default-ednize [x] (as-inst x))\n  java.sql.Timestamp (default-ednize [x] (as-inst x))\n  clojure.lang.Namespace (default-ednize [x] (tagged-literal 'unrepl/ns (ns-name x)))\n  java.util.regex.Pattern (default-ednize [x] (tagged-literal 'unrepl/pattern (str x)))\n  Object\n  (default-ednize [x]\n    (tagged-literal 'unrepl/object\n      [(class x) (format \"0x%x\" (System/identityHashCode x)) (object-representation x)\n       {:bean {(tagged-literal 'unrepl/... (*elide* (ElidedKVs. (bean x)))) (tagged-literal 'unrepl/... nil)}}])))\n\n(def ^:dynamic *ednize* default-ednize)\n\n(def ^:dynamic *realize-on-print*\n  \"Set to false to avoid realizing lazy sequences.\"\n  true)\n\n(defmacro ^:private blame-seq [& body]\n  `(try (seq ~@body)\n     (catch Throwable t#\n       (list (tagged-literal 'unrepl/lazy-error t#)))))\n\n(defn- may-print? [s]\n  (or *realize-on-print* (not (instance? clojure.lang.IPending s)) (realized? s)))\n\n(defn- elide-vs [vs print-length]\n  (cond\n    (pos? print-length)\n    (lazy-seq\n      (if (may-print? vs)\n        (if-some [[v :as vs] (blame-seq vs)]\n          (cons v (elide-vs (rest vs) (dec print-length)))\n          ())\n        (list (tagged-literal 'unrepl/... (*elide* vs)))))\n    (and (may-print? vs) (nil? (blame-seq vs))) ()\n    :else (list (tagged-literal 'unrepl/... (*elide* vs)))))\n\n(defn- elide-kvs [kvs print-length]\n  (if-some [more-kvs (when print-length (seq (drop print-length kvs)))]\n    (concat (take print-length kvs) [[(tagged-literal 'unrepl/... (*elide* (ElidedKVs. more-kvs))) (tagged-literal 'unrepl/... nil)]])\n    kvs))\n\n(defn ednize \"Shallow conversion to edn safe subset.\" \n  ([x] (ednize x *print-length* *print-meta*))\n  ([x print-length] (ednize x print-length *print-meta*))\n  ([x print-length print-meta]\n  (cond\n    (atomic? x) x\n    (and print-meta (meta x)) (tagged-literal 'unrepl/meta [(meta x) (ednize x print-length false)])\n    (map? x) (into {} (elide-kvs x print-length))\n    (instance? ElidedKVs x) (ElidedKVs. (elide-kvs x print-length))\n    (instance? clojure.lang.MapEntry x) x\n    (vector? x) (into (empty x) (elide-vs x print-length))\n    (seq? x) (elide-vs x print-length)\n    (set? x) (into #{} (elide-vs x print-length))\n    :else (let [x' (*ednize* x)]\n            (if (= x x')\n              x\n              (recur x' print-length print-meta)))))) ; todo : cache\n\n(declare print-on)\n\n(defn- print-vs \n  ([write vs rem-depth]\n    (print-vs write vs rem-depth print-on \" \"))\n  ([write vs rem-depth print-v sep]\n    (when-some [[v & vs] (seq vs)]\n      (print-v write v rem-depth)\n      (doseq [v vs]\n        (write sep)\n        (print-v write v rem-depth)))))\n\n(defn- print-kv [write [k v] rem-depth]\n  (print-on write k rem-depth)\n  (write \" \")\n  (print-on write v rem-depth))\n\n(defn- print-kvs [write kvs rem-depth]\n    (print-vs write kvs rem-depth print-kv \", \"))\n\n(defn- print-on [write x rem-depth]\n  (let [rem-depth (dec rem-depth)\n        x (ednize x (if (neg? rem-depth) 0 *print-length*))]\n    (cond\n      (tagged-literal? x)\n      (do (write (str \"#\" (:tag x) \" \"))\n        (case (:tag x)\n          unrepl/... (binding ; don't elide the elision \n                       [*print-length* Long/MAX_VALUE]\n                       (print-on write (:form x) Long/MAX_VALUE))\n          (recur write (:form x) rem-depth)))\n      (or (map? x) (instance? ElidedKVs x)) (do (write \"{\") (print-kvs write x rem-depth) (write \"}\"))\n      (vector? x) (do (write \"[\") (print-vs write x rem-depth) (write \"]\"))\n      (seq? x) (do (write \"(\") (print-vs write x rem-depth) (write \")\"))\n      (set? x) (do (write \"#{\") (print-vs write x rem-depth) (write \"}\"))\n      (atomic? x) (write (as-str x))\n      :else (throw (ex-info \"Can't print value.\" {:value x})))))\n\n(defn edn-str [x]\n  (let [out (java.io.StringWriter.)\n        write (fn [^String s] (.write out s))]\n    (binding [*print-readably* true\n              *print-length* (or *print-length* 10)]\n      (print-on write x (or *print-level* 8))\n      (str out))))\n\n(defn full-edn-str [x]\n  (binding [*print-length* Long/MAX_VALUE\n            *print-level* Long/MAX_VALUE]\n    (edn-str x)))\n(ns unrepl.repl\n  (:require [clojure.main :as m]\n    [unrepl.print :as p]))\n\n(defn tagging-writer\n  ([write]\n    (proxy [java.io.Writer] []\n      (close []) ; do not cascade\n      (flush []) ; atomic always flush\n      (write\n        ([x]\n          (write (cond \n                   (string? x) x\n                   (integer? x) (str (char x))\n                   :else (String. ^chars x))))\n        ([string-or-chars off len]\n          (when (pos? len)\n            (write (subs (if (string? string-or-chars) string-or-chars (String. ^chars string-or-chars))\n                     off (+ off len))))))))\n  ([tag write]\n    (tagging-writer (fn [s] (write [tag s]))))\n  ([tag group-id write]\n    (tagging-writer (fn [s] (write [tag s group-id])))))\n\n(defn blame-ex [phase ex]\n  (if (::phase (ex-data ex))\n    ex\n    (ex-info (str \"Exception during \" (name phase) \" phase.\")\n      {::ex ex ::phase phase} ex)))\n\n(defmacro blame [phase & body]\n  `(try ~@body\n     (catch Throwable t#\n       (throw (blame-ex ~phase t#)))))\n\n(defn atomic-write [^java.io.Writer w]\n  (fn [x]\n    (let [s (blame :print (p/edn-str x))] ; was pr-str, must occur outside of the locking form to avoid deadlocks\n      (locking w\n        (.write w s)\n        (.write w \"\\n\")\n        (.flush w)))))\n\n(defn fuse-write [awrite]\n  (fn [x]\n    (when-some [w @awrite]\n      (try\n        (w x)\n        (catch Throwable t\n          (reset! awrite nil))))))\n\n(def ^:dynamic write)\n\n(defn unrepl-reader [^java.io.Reader r before-read]\n  (let [offset (atom 0)\n        offset! #(swap! offset + %)]\n    (proxy [clojure.lang.LineNumberingPushbackReader clojure.lang.ILookup] [r]\n      (valAt\n        ([k] (get this k nil))\n        ([k not-found] (case k :offset @offset not-found)))\n      (read\n        ([]\n          (before-read)\n          (let [c (proxy-super read)]\n            (when-not (neg? c) (offset! 1))\n            c))\n        ([cbuf]\n          (before-read)\n          (let [n (proxy-super read cbuf)]\n            (when (pos? n) (offset! n))\n            n))\n        ([cbuf off len]\n          (before-read)\n          (let [n (proxy-super read cbuf off len)]\n            (when (pos? n) (offset! n))\n            n)))\n      (unread\n        ([c-or-cbuf]\n          (if (integer? c-or-cbuf)\n            (when-not (neg? c-or-cbuf) (offset! -1))\n            (offset! (- (alength c-or-cbuf))))\n          (proxy-super unread c-or-cbuf))\n        ([cbuf off len]\n          (offset! (- len))\n          (proxy-super unread cbuf off len)))\n      (skip [n]\n        (let [n (proxy-super skip n)]\n          (offset! n)\n          n))\n      (readLine []\n        (when-some [s (proxy-super readLine)]\n          (offset! (count s))\n          s)))))\n\n(defn- close-socket! [x]\n  ; hacky way because the socket is not exposed by clojure.core.server\n  (loop [x x]\n    (if (= \"java.net.SocketInputStream\" (.getName (class x)))\n      (do (.close x) true)\n      (when-some [^java.lang.reflect.Field field \n                  (->> x class (iterate #(.getSuperclass %)) (take-while identity)\n                    (mapcat #(.getDeclaredFields %))\n                    (some #(when (#{\"in\" \"sd\"} (.getName ^java.lang.reflect.Field %)) %)))]\n        (recur (.get (doto field (.setAccessible true)) x))))))\n\n(defn weak-store [make-action not-found]\n  (let [ids-to-weakrefs (atom {})\n        weakrefs-to-ids (atom {})\n        refq (java.lang.ref.ReferenceQueue.)\n        NULL (Object.)]\n    (.start (Thread. (fn []\n                       (let [wref (.remove refq)]\n                         (let [id (@weakrefs-to-ids wref)]\n                           (swap! weakrefs-to-ids dissoc wref)\n                           (swap! ids-to-weakrefs dissoc id)))\n                           (recur))))\n    {:put (fn [x]\n            (let [x (if (nil? x) NULL x)\n                  id (keyword (gensym))\n                  wref (java.lang.ref.WeakReference. x refq)]\n              (swap! weakrefs-to-ids assoc wref id)\n              (swap! ids-to-weakrefs assoc id wref)\n              {:get (make-action id)}))\n     :get (fn [id]\n            (if-some [x (some-> @ids-to-weakrefs ^java.lang.ref.WeakReference (get id) .get)]\n              (if (= NULL x) nil x)\n              not-found))}))\n\n(defn- base64-str [^java.io.InputStream in]\n  (let [table \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n        sb (StringBuilder.)]\n    (loop [shift 4 buf 0]\n      (let [got (.read in)]\n        (if (neg? got)\n          (do\n            (when-not (= shift 4)\n              (let [n (bit-and (bit-shift-right buf 6) 63)]\n                (.append sb (.charAt table n))))\n            (cond\n              (= shift 2) (.append sb \"==\")\n              (= shift 0) (.append sb \\=))\n            (str sb))\n          (let [buf (bit-or buf (bit-shift-left got shift))\n                n (bit-and (bit-shift-right buf 6) 63)]\n            (.append sb (.charAt table n))\n            (let [shift (- shift 2)]\n              (if (neg? shift)\n                (do\n                  (.append sb (.charAt table (bit-and buf 63)))\n                  (recur 4 0))\n                (recur shift (bit-shift-left buf 6))))))))))\n\n(defonce ^:private sessions (atom {}))\n\n(def ^:private unreachable (tagged-literal 'unrepl/... nil))\n(defonce ^:private elision-store (weak-store #(list `fetch %) unreachable))\n(defn fetch [id] \n  (let [x ((:get elision-store) id)]\n    (cond\n      (= unreachable x) x\n      (instance? unrepl.print.ElidedKVs x) x\n      :else (seq x))))\n\n(defonce ^:private attachment-store (weak-store #(list `download %) (constantly nil)))\n(defn download [id] ((:get attachment-store) id))\n\n(defn session [id]\n  (some-> @sessions (get id) deref))\n\n(defn interrupt! [session-id eval]\n  (let [{:keys [^Thread thread eval-id promise]}\n        (some-> session-id session :current-eval)]\n    (when (and (= eval eval-id)\n            (deliver promise\n              {:ex (doto (ex-info \"Evaluation interrupted\" {::phase :eval})\n                     (.setStackTrace (.getStackTrace thread)))\n               :bindings {}}))\n      (.stop thread)\n      true)))\n\n(defn background! [session-id eval]\n  (let [{:keys [eval-id promise future]}\n        (some-> session-id session :current-eval)]\n    (boolean\n      (and\n        (= eval eval-id)\n        (deliver promise\n          {:eval future\n           :bindings {}})))))\n\n(defn exit! [session-id] ; too violent\n  (some-> session-id session :in close-socket!))\n\n(defn reattach-outs! [session-id]\n  (some-> session-id session :write-atom \n    (reset!\n      (if (bound? #'write)\n        write\n        (let [out *out*]\n          (fn [x]\n            (binding [*out* out\n                      *print-readably* true]\n              (prn x))))))))\n\n(defn set-file-line-col [session-id file line col]\n  (when-some [^java.lang.reflect.Field field \n              (->> clojure.lang.LineNumberingPushbackReader\n                .getDeclaredFields\n                (some #(when (= \"_columnNumber\" (.getName ^java.lang.reflect.Field %)) %)))]\n    (doto field (.setAccessible true)) ; sigh\n    (when-some [in (some-> session-id session :in)]\n      (set! *file* file)\n      (set! *source-path* file)\n      (.setLineNumber in line)\n      (.set field in (int col)))))\n\n(defn start []\n  (with-local-vars [in-eval false\n                    unrepl false\n                    eval-id 0\n                    prompt-vars #{#'*ns* #'*warn-on-reflection*}\n                    current-eval-future nil]\n    (let [session-id (keyword (gensym \"session\"))\n          raw-out *out*\n          aw (atom (atomic-write raw-out))\n          write-here (fuse-write aw)\n          edn-out (tagging-writer :out write-here)\n          ensure-raw-repl (fn []\n                            (when (and @in-eval @unrepl) ; reading from eval!\n                              (var-set unrepl false)\n                              (write [:bye {:reason :upgrade :actions {}}])\n                              (flush)\n                              ; (reset! aw (blocking-write))\n                              (set! *out* raw-out)))\n          in (unrepl-reader *in* ensure-raw-repl)\n          session-state (atom {:current-eval {}\n                               :in in\n                               :write-atom aw\n                               :log-eval (fn [msg]\n                                           (when (bound? eval-id)\n                                             (write [:log msg @eval-id])))\n                               :log-all (fn [msg]\n                                          (write [:log msg nil]))\n                               :prompt-vars #{#'*ns* #'*warn-on-reflection*}})\n          current-eval-thread+promise (atom nil)\n          ensure-unrepl (fn []\n                          (when-not @unrepl\n                            (var-set unrepl true)\n                            (flush)\n                            (set! *out* edn-out)\n                            (binding [*print-length* Long/MAX_VALUE\n                                      *print-level* Long/MAX_VALUE]\n                              (write [:unrepl/hello {:session session-id\n                                                     :actions {:exit `(exit! ~session-id)\n                                                               :log-eval\n                                                               `(some-> ~session-id session :log-eval)\n                                                               :log-all\n                                                               `(some-> ~session-id session :log-all)\n                                                               :set-source\n                                                               `(unrepl/do\n                                                                  (set-file-line-col ~session-id\n                                                                   ~(tagged-literal 'unrepl/param :unrepl/sourcename)\n                                                                   ~(tagged-literal 'unrepl/param :unrepl/line)\n                                                                   ~(tagged-literal 'unrepl/param :unrepl/column)))}}]))))\n          \n          interruptible-eval\n          (fn [form]\n            (try\n              (let [original-bindings (get-thread-bindings)\n                    p (promise)\n                    f\n                    (future\n                      (swap! session-state update :current-eval\n                        assoc :thread (Thread/currentThread))\n                      (with-bindings original-bindings\n                        (try\n                          (write [:started-eval\n                                  {:actions \n                                   {:interrupt (list `interrupt! session-id @eval-id)\n                                    :background (list `background! session-id @eval-id)}}\n                                  @eval-id])\n                          (let [v (with-bindings {in-eval true}\n                                    (blame :eval (eval form)))]\n                            (deliver p {:eval v :bindings (get-thread-bindings)})\n                            v)\n                          (catch Throwable t\n                            (deliver p {:ex t :bindings (get-thread-bindings)})\n                            (throw t)))))]\n                (swap! session-state update :current-eval\n                  into {:eval-id @eval-id :promise p :future f})\n                (let [{:keys [ex eval bindings]} @p]\n                  (doseq [[var val] bindings\n                          :when (not (identical? val (original-bindings var)))]\n                    (var-set var val))\n                  (if ex\n                    (throw ex)\n                    eval)))\n              (finally\n                (swap! session-state assoc :current-eval {}))))]\n      (swap! sessions assoc session-id session-state)\n      (binding [*out* raw-out\n                *err* (tagging-writer :err write)\n                *in* in\n                *file* \"unrepl-session\"\n                *source-path* \"unrepl-session\"\n                p/*elide* (:put elision-store)\n                p/*attach* (:put attachment-store)\n                write write-here]\n        (m/repl\n          :prompt (fn []\n                    (ensure-unrepl)\n                    (write [:prompt (into {:file *file*\n                                           :line (.getLineNumber *in*)\n                                           :column (.getColumnNumber *in*)\n                                           :offset (:offset *in*)}\n                                      (map (fn [v]\n                                             (let [m (meta v)]\n                                               [(symbol (name (ns-name (:ns m))) (name (:name m))) @v])))\n                                      (:prompt-vars @session-state))]))\n          :read (fn [request-prompt request-exit]\n                  (blame :read (let [line+col [(.getLineNumber *in*) (.getColumnNumber *in*)]\n                                     offset (:offset *in*)\n                                     r (m/repl-read request-prompt request-exit)\n                                     line+col' [(.getLineNumber *in*) (.getColumnNumber *in*)]\n                                     offset' (:offset *in*)\n                                     len (- offset' offset)\n                                     id (when-not (#{request-prompt request-exit} r)\n                                          (var-set eval-id (inc @eval-id)))]\n                                 (write [:read {:from line+col :to line+col'\n                                                :offset offset\n                                                :len (- offset' offset)}\n                                         id])\n                                 (if (and (seq?  r) (= (first r) 'unrepl/do))\n                                   (let [id @eval-id]\n                                     (binding [*err* (tagging-writer :err id write)\n                                               *out* (tagging-writer :out id write)]\n                                       (eval (cons 'do (next r))))\n                                     request-prompt)\n                                   r))))\n          :eval (fn [form]\n                  (let [id @eval-id]\n                    (binding [*err* (tagging-writer :err id write)\n                              *out* (tagging-writer :out id write)]\n                      (interruptible-eval form))))\n          :print (fn [x]\n                   (ensure-unrepl)\n                   (write [:eval x @eval-id]))\n          :caught (fn [e]\n                    (ensure-unrepl)\n                    (let [{:keys [::ex ::phase]\n                           :or {ex e phase :repl}} (ex-data e)]\n                      (write [:exception {:ex e :phase phase} @eval-id]))))\n        (write [:bye {:reason :disconnection\n                      :outs :muted\n                      :actions {:reattach-outs `(reattach-outs! ~session-id)}}])))))\n\n(unrepl.repl/start)" "unrepl\\.(?:repl|print)" (clojure.core/str "$0" prefix__641__auto__)) rdr__643__auto__ (clojure.core/-> code__642__auto__ java.io.StringReader. clojure.lang.LineNumberingPushbackReader.)] (try (clojure.core/binding [clojure.core/*ns* clojure.core/*ns*] (clojure.core/loop [ret__644__auto__ nil] (clojure.core/let [form__645__auto__ (clojure.core/read rdr__643__auto__ false (quote eof__646__auto__))] (if (clojure.core/= (quote eof__646__auto__) form__645__auto__) ret__644__auto__ (recur (clojure.core/eval form__645__auto__)))))) (catch java.lang.Throwable t__647__auto__ (clojure.core/println "[:unrepl.upgrade/failed]") (throw t__647__auto__))))
